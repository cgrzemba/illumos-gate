/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "sys/lvm/md_basic.h"

#ifndef _KERNEL
#include <stdlib.h>
#endif /* !_KERNEL */

/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

/* get timeval32 definition */
#include <sys/types32.h>
#include <sys/dditypes.h>
#ifdef _LP64
bool_t
xdr_timeval(XDR *xdrs, struct timeval *objp)
{
	struct timeval32 tv32;
	if (xdrs->x_op == XDR_ENCODE)
		TIMEVAL_TO_TIMEVAL32(&tv32, objp);
	if (!xdr_int(xdrs, &tv32.tv_sec))
		return (FALSE);
	if (!xdr_int(xdrs, &tv32.tv_usec))
		return (FALSE);
	if (xdrs->x_op == XDR_DECODE)
		TIMEVAL32_TO_TIMEVAL(objp, &tv32);
	return (TRUE);
}
#else /* !_LP64 */
bool_t
xdr_timeval(XDR *xdrs, struct timeval *objp)
{
	if (!xdr_int(xdrs, (int *)&objp->tv_sec))
		return (FALSE);
	if (!xdr_int(xdrs, (int *)&objp->tv_usec))
		return (FALSE);
	return (TRUE);
}
#endif /* _LP64 */

bool_t
xdr_minor_t(XDR *xdrs, minor_t *objp)
{
	if (!xdr_u_int(xdrs, (u_int *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_clnt_stat(XDR *xdrs, enum clnt_stat *objp)
{
	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

/* namespace key */

bool_t
xdr_mdkey_t(XDR *xdrs, mdkey_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

/* set ID */

bool_t
xdr_set_t(XDR *xdrs, set_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_u_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

/* record ID type */

bool_t
xdr_mddb_recid_t(XDR *xdrs, mddb_recid_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

/* side ID */

bool_t
xdr_side_t(XDR *xdrs, side_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_u_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

/* Multi-node node ID */

bool_t
xdr_md_mn_nodeid_t(XDR *xdrs, md_mn_nodeid_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_uint32_t(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

/* Shared definitions */
/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

#pragma ident	"%Z%%M%	%I%	%E% SMI"

/*
 * This file has the shared fixed array RPC definitions for use in a couple
 * places.
 */


/*
 * Node Name type
 */

bool_t
xdr_md_node_nm_t(XDR *xdrs, md_node_nm_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MD_MAX_NODENAME_PLUS_1,
		sizeof (char), (xdrproc_t)xdr_char))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_mnnode_nm_t(XDR *xdrs, md_mnnode_nm_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MD_MAX_MNNODENAME_PLUS_1,
		sizeof (char), (xdrproc_t)xdr_char))
		return (FALSE);
	return (TRUE);
}

/*
 * Set Name Type
 */

bool_t
xdr_md_set_nm_t(XDR *xdrs, md_set_nm_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MD_MAX_SETNAME_PLUS_1,
		sizeof (char), (xdrproc_t)xdr_char))
		return (FALSE);
	return (TRUE);
}

/*
 * Mediator Basic Data Types
 */

bool_t
xdr_md_alias_nm_t(XDR *xdrs, md_alias_nm_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MAX_HOST_ADDRS,
		sizeof (md_node_nm_t), (xdrproc_t)xdr_md_node_nm_t))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_alias_ip_t(XDR *xdrs, md_alias_ip_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MAX_HOST_ADDRS,
		sizeof (u_int), (xdrproc_t)xdr_u_int))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_hi_t(XDR *xdrs, md_hi_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_u_int(xdrs, &objp->a_flg))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->a_cnt))
		return (FALSE);
	if (!xdr_md_alias_nm_t(xdrs, objp->a_nm))
		return (FALSE);
	if (!xdr_md_alias_ip_t(xdrs, objp->a_ip))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_hi_arr_t(XDR *xdrs, md_hi_arr_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_int(xdrs, &objp->n_cnt))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->n_lst, MED_MAX_HOSTS,
		sizeof (md_hi_t), (xdrproc_t)xdr_md_hi_t))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_h_t(XDR *xdrs, md_h_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_int(xdrs, &objp->a_cnt))
		return (FALSE);
	if (!xdr_md_alias_nm_t(xdrs, objp->a_nm))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_h_arr_t(XDR *xdrs, md_h_arr_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_int(xdrs, &objp->n_cnt))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->n_lst, MED_MAX_HOSTS,
		sizeof (md_h_t), (xdrproc_t)xdr_md_h_t))
		return (FALSE);
	return (TRUE);
}

/*
 * Node Name type
 */

bool_t
xdr_md_node_nm_arr_t(XDR *xdrs, md_node_nm_arr_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MD_MAXSIDES,
		sizeof (md_node_nm_t), (xdrproc_t)xdr_md_node_nm_t))
		return (FALSE);
	return (TRUE);
}

