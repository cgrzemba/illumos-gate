/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "sys/lvm/mdmed.h"

#ifndef _KERNEL
#include <stdlib.h>
#endif /* !_KERNEL */

/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

#pragma ident	"%Z%%M%	%I%	%E% SMI"

#include <sys/types.h>
#include <sys/errno.h>
#include <sys/utsname.h>

#include <sys/lvm/md_basic.h>

/*
 * mediator (med) errors, definition of MDE_MED_HOSTNOMED must be changed
 * when new errors are added, since MDE_MED_NOERROR has to come out to
 * be zero!
 */

bool_t
xdr_md_med_errno_t(XDR *xdrs, md_med_errno_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_med_err_t(XDR *xdrs, med_err_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_int(xdrs, &objp->med_errno))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->med_node, ~0))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->med_misc, ~0))
		return (FALSE);
	return (TRUE);
}
/* Mediator records in MN diskset have all callers set to multiowner */
#define	MED_MN_CALLER	"multiowner"


/* Start - Avoid duplicate definitions, but get the xdr calls right */
#if 0
/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 *
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the "License").  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

#pragma ident	"%Z%%M%	%I%	%E% SMI"

/*
 * This file has the shared fixed array RPC definitions for use in a couple
 * places.
 */


/*
 * Node Name type
 */

bool_t
xdr_md_node_nm_t(XDR *xdrs, md_node_nm_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MD_MAX_NODENAME_PLUS_1,
		sizeof (char), (xdrproc_t)xdr_char))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_mnnode_nm_t(XDR *xdrs, md_mnnode_nm_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MD_MAX_MNNODENAME_PLUS_1,
		sizeof (char), (xdrproc_t)xdr_char))
		return (FALSE);
	return (TRUE);
}

/*
 * Set Name Type
 */

bool_t
xdr_md_set_nm_t(XDR *xdrs, md_set_nm_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MD_MAX_SETNAME_PLUS_1,
		sizeof (char), (xdrproc_t)xdr_char))
		return (FALSE);
	return (TRUE);
}

/*
 * Mediator Basic Data Types
 */

bool_t
xdr_md_alias_nm_t(XDR *xdrs, md_alias_nm_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MAX_HOST_ADDRS,
		sizeof (md_node_nm_t), (xdrproc_t)xdr_md_node_nm_t))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_alias_ip_t(XDR *xdrs, md_alias_ip_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MAX_HOST_ADDRS,
		sizeof (u_int), (xdrproc_t)xdr_u_int))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_hi_t(XDR *xdrs, md_hi_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_u_int(xdrs, &objp->a_flg))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->a_cnt))
		return (FALSE);
	if (!xdr_md_alias_nm_t(xdrs, objp->a_nm))
		return (FALSE);
	if (!xdr_md_alias_ip_t(xdrs, objp->a_ip))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_hi_arr_t(XDR *xdrs, md_hi_arr_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_int(xdrs, &objp->n_cnt))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->n_lst, MED_MAX_HOSTS,
		sizeof (md_hi_t), (xdrproc_t)xdr_md_hi_t))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_h_t(XDR *xdrs, md_h_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_int(xdrs, &objp->a_cnt))
		return (FALSE);
	if (!xdr_md_alias_nm_t(xdrs, objp->a_nm))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_md_h_arr_t(XDR *xdrs, md_h_arr_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_int(xdrs, &objp->n_cnt))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->n_lst, MED_MAX_HOSTS,
		sizeof (md_h_t), (xdrproc_t)xdr_md_h_t))
		return (FALSE);
	return (TRUE);
}

/*
 * Node Name type
 */

bool_t
xdr_md_node_nm_arr_t(XDR *xdrs, md_node_nm_arr_t objp)
{

	rpc_inline_t *buf;

	if (!xdr_vector(xdrs, (char *)objp, MD_MAXSIDES,
		sizeof (md_node_nm_t), (xdrproc_t)xdr_md_node_nm_t))
		return (FALSE);
	return (TRUE);
}

#endif	/* 0 */
/* End   - Avoid duplicate definitions, but get the xdr calls right */



bool_t
xdr_med_data_t(XDR *xdrs, med_data_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_u_int(xdrs, &objp->med_dat_mag))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->med_dat_rev))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->med_dat_cks))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->med_dat_fl))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->med_dat_cc))
		return (FALSE);
	if (!xdr_set_t(xdrs, &objp->med_dat_sn))
		return (FALSE);
	if (!xdr_timeval(xdrs, &objp->med_dat_id))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->med_dat_spare))
		return (FALSE);
	return (TRUE);
}


bool_t
xdr_med_med_t(XDR *xdrs, med_med_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_set_t(xdrs, &objp->med_setno))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->med_setname, ~0))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->med_caller, ~0))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_med_args_t(XDR *xdrs, med_args_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_med_med_t(xdrs, &objp->med))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_med_res_t(XDR *xdrs, med_res_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_med_err_t(xdrs, &objp->med_status))
		return (FALSE);
	if (!xdr_med_med_t(xdrs, &objp->med))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_med_get_data_res_t(XDR *xdrs, med_get_data_res_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_med_err_t(xdrs, &objp->med_status))
		return (FALSE);
	if (!xdr_med_data_t(xdrs, &objp->med_data))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_med_upd_data_args_t(XDR *xdrs, med_upd_data_args_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_med_med_t(xdrs, &objp->med))
		return (FALSE);
	if (!xdr_med_data_t(xdrs, &objp->med_data))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_med_hnm_res_t(XDR *xdrs, med_hnm_res_t *objp)
{

	rpc_inline_t *buf;

	if (!xdr_med_err_t(xdrs, &objp->med_status))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->med_hnm, ~0))
		return (FALSE);
	return (TRUE);
}

/*
 * Constant null error struct.
 */
const		med_err_t		med_null_err = MED_NULL_ERR;
const	struct	timeval			md_med_def_timeout = MD_MED_DEF_TO;
const	struct	timeval			md_med_pmap_timeout = MD_MED_PMAP_TO;
