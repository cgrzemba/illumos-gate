/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "/code/illumos-gate/usr/src/uts/common/rpcsvc/idmap_prot.h"

#ifndef _KERNEL
#include <stdlib.h>
#endif /* !_KERNEL */

#if	defined(_KERNEL)
#include <sys/nvpair.h>
#else
#include <libnvpair.h>
#endif
#if	!defined(_KERNEL)
#include <string.h>
#include <stdio.h>
#endif

bool_t
xdr_nvlist_t_ptr(XDR *xdrs, nvlist_t_ptr *n)
{
	char *buf;
	u_int len;
	bool_t ret;
	int err;
	size_t	sz;
	bool_t	present;

	switch (xdrs->x_op) {
	case XDR_DECODE:
		if (!xdr_bool(xdrs, &present))
			return (FALSE);
		if (!present) {
			*n = NULL;
			return (TRUE);
		}
		buf = NULL;
		if (!xdr_bytes(xdrs, &buf, &len, ~0))
			return (FALSE);

		err = nvlist_unpack(buf, (size_t)len, n, 0);
#if	defined(_KERNEL)
		kmem_free(buf, len);
#else
		free(buf);
#endif

		if (err != 0) {
#if	!defined(_KERNEL)
			fprintf(stderr, "xdr_nvlist_t unpack:  %s\n",
			    strerror(err));
#endif
			return (FALSE);
		}
		return (TRUE);

	case XDR_ENCODE:
		present = (*n != NULL);
		if (!xdr_bool(xdrs, &present))
			return (FALSE);
		if (!present)
			return (TRUE);
		buf = NULL;
		err = nvlist_pack(*n, &buf, &sz, NV_ENCODE_XDR, 0);
		if (err != 0) {
#if	!defined(_KERNEL)
			fprintf(stderr, "xdr_nvlist_t pack:  %s\n",
			    strerror(err));
#endif
			return (FALSE);
		}

		/* nvlist_pack() and xdr_bytes() want different types */
		len = (u_int) sz;

		ret = xdr_bytes(xdrs, &buf, &len, ~0);
#if	defined(_KERNEL)
		kmem_free(buf, len);
#else
		free(buf);
#endif

		return (ret);

	case XDR_FREE:
		if (*n != NULL) {
			nvlist_free(*n);
			*n = NULL;
		}
		return (TRUE);

	default:
		return (FALSE);
	}
}

bool_t
xdr_idmap_utf8str(XDR *xdrs, idmap_utf8str *objp)
{

	rpc_inline_t *buf;

	if (!xdr_string(xdrs, objp, ~0))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_utf8str_list(XDR *xdrs, idmap_utf8str_list *objp)
{

	rpc_inline_t *buf;

	if (!xdr_array(xdrs, (char **)&objp->idmap_utf8str_list_val, (u_int *) &objp->idmap_utf8str_list_len, ~0,
		sizeof (idmap_utf8str), (xdrproc_t)xdr_idmap_utf8str))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_retcode(XDR *xdrs, idmap_retcode *objp)
{

	rpc_inline_t *buf;

	if (!xdr_int(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_id_type(XDR *xdrs, idmap_id_type *objp)
{

	rpc_inline_t *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_map_type(XDR *xdrs, idmap_map_type *objp)
{

	rpc_inline_t *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_map_src(XDR *xdrs, idmap_map_src *objp)
{

	rpc_inline_t *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_sid(XDR *xdrs, idmap_sid *objp)
{

	rpc_inline_t *buf;

	if (!xdr_string(xdrs, &objp->prefix, ~0))
		return (FALSE);
	if (!xdr_uint32_t(xdrs, &objp->rid))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_id(XDR *xdrs, idmap_id *objp)
{

	rpc_inline_t *buf;

	if (!xdr_idmap_id_type(xdrs, &objp->idtype))
		return (FALSE);
	switch (objp->idtype) {
	case IDMAP_UID:
		if (!xdr_uint32_t(xdrs, &objp->idmap_id_u.uid))
			return (FALSE);
		break;
	case IDMAP_GID:
		if (!xdr_uint32_t(xdrs, &objp->idmap_id_u.gid))
			return (FALSE);
		break;
	case IDMAP_SID:
		if (!xdr_idmap_sid(xdrs, &objp->idmap_id_u.sid))
			return (FALSE);
		break;
	case IDMAP_USID:
		if (!xdr_idmap_sid(xdrs, &objp->idmap_id_u.usid))
			return (FALSE);
		break;
	case IDMAP_GSID:
		if (!xdr_idmap_sid(xdrs, &objp->idmap_id_u.gsid))
			return (FALSE);
		break;
	case IDMAP_NONE:
		break;
	case IDMAP_POSIXID:
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_idmap_namerule(XDR *xdrs, idmap_namerule *objp)
{

	rpc_inline_t *buf;

	if (!xdr_bool(xdrs, &objp->is_user))
		return (FALSE);
	if (!xdr_bool(xdrs, &objp->is_wuser))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->direction))
		return (FALSE);
	if (!xdr_idmap_utf8str(xdrs, &objp->windomain))
		return (FALSE);
	if (!xdr_idmap_utf8str(xdrs, &objp->winname))
		return (FALSE);
	if (!xdr_idmap_utf8str(xdrs, &objp->unixname))
		return (FALSE);
	if (!xdr_bool(xdrs, &objp->is_nt4))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_namerules_res(XDR *xdrs, idmap_namerules_res *objp)
{

	rpc_inline_t *buf;

	if (!xdr_idmap_retcode(xdrs, &objp->retcode))
		return (FALSE);
	if (!xdr_uint64_t(xdrs, &objp->lastrowid))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->rules.rules_val, (u_int *) &objp->rules.rules_len, ~0,
		sizeof (idmap_namerule), (xdrproc_t)xdr_idmap_namerule))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_how_ds_based(XDR *xdrs, idmap_how_ds_based *objp)
{

	rpc_inline_t *buf;

	if (!xdr_idmap_utf8str(xdrs, &objp->dn))
		return (FALSE);
	if (!xdr_idmap_utf8str(xdrs, &objp->attr))
		return (FALSE);
	if (!xdr_idmap_utf8str(xdrs, &objp->value))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_how(XDR *xdrs, idmap_how *objp)
{

	rpc_inline_t *buf;

	if (!xdr_idmap_map_type(xdrs, &objp->map_type))
		return (FALSE);
	switch (objp->map_type) {
	case IDMAP_MAP_TYPE_UNKNOWN:
		break;
	case IDMAP_MAP_TYPE_DS_AD:
		if (!xdr_idmap_how_ds_based(xdrs, &objp->idmap_how_u.ad))
			return (FALSE);
		break;
	case IDMAP_MAP_TYPE_DS_NLDAP:
		if (!xdr_idmap_how_ds_based(xdrs, &objp->idmap_how_u.nldap))
			return (FALSE);
		break;
	case IDMAP_MAP_TYPE_RULE_BASED:
		if (!xdr_idmap_namerule(xdrs, &objp->idmap_how_u.rule))
			return (FALSE);
		break;
	case IDMAP_MAP_TYPE_EPHEMERAL:
		break;
	case IDMAP_MAP_TYPE_LOCAL_SID:
		break;
	case IDMAP_MAP_TYPE_KNOWN_SID:
		break;
	case IDMAP_MAP_TYPE_IDMU:
		if (!xdr_idmap_how_ds_based(xdrs, &objp->idmap_how_u.idmu))
			return (FALSE);
		break;
	default:
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_idmap_info(XDR *xdrs, idmap_info *objp)
{

	rpc_inline_t *buf;

	if (!xdr_idmap_map_src(xdrs, &objp->src))
		return (FALSE);
	if (!xdr_idmap_how(xdrs, &objp->how))
		return (FALSE);
	if (!xdr_nvlist_t_ptr(xdrs, &objp->trace))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_id_res(XDR *xdrs, idmap_id_res *objp)
{

	rpc_inline_t *buf;

	if (!xdr_idmap_retcode(xdrs, &objp->retcode))
		return (FALSE);
	if (!xdr_idmap_id(xdrs, &objp->id))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->direction))
		return (FALSE);
	if (!xdr_idmap_info(xdrs, &objp->info))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_ids_res(XDR *xdrs, idmap_ids_res *objp)
{

	rpc_inline_t *buf;

	if (!xdr_idmap_retcode(xdrs, &objp->retcode))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->ids.ids_val, (u_int *) &objp->ids.ids_len, ~0,
		sizeof (idmap_id_res), (xdrproc_t)xdr_idmap_id_res))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_mapping(XDR *xdrs, idmap_mapping *objp)
{

	rpc_inline_t *buf;

	if (!xdr_int32_t(xdrs, &objp->flag))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->direction))
		return (FALSE);
	if (!xdr_idmap_id(xdrs, &objp->id1))
		return (FALSE);
	if (!xdr_idmap_utf8str(xdrs, &objp->id1domain))
		return (FALSE);
	if (!xdr_idmap_utf8str(xdrs, &objp->id1name))
		return (FALSE);
	if (!xdr_idmap_id(xdrs, &objp->id2))
		return (FALSE);
	if (!xdr_idmap_utf8str(xdrs, &objp->id2domain))
		return (FALSE);
	if (!xdr_idmap_utf8str(xdrs, &objp->id2name))
		return (FALSE);
	if (!xdr_idmap_info(xdrs, &objp->info))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_idmap_mapping_batch(XDR *xdrs, idmap_mapping_batch *objp)
{

	rpc_inline_t *buf;

	if (!xdr_array(xdrs, (char **)&objp->idmap_mapping_batch_val, (u_int *) &objp->idmap_mapping_batch_len, ~0,
		sizeof (idmap_mapping), (xdrproc_t)xdr_idmap_mapping))
		return (FALSE);
	return (TRUE);
}
