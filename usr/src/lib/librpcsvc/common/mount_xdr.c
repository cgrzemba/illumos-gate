/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "../../head/rpcsvc/mount.h"

#ifndef _KERNEL
#include <stdlib.h>
#endif /* !_KERNEL */


bool_t
xdr_fhandle(xdrs, objp)
	XDR *xdrs;
	fhandle objp;
{

	rpc_inline_t *buf;

	if (!xdr_opaque(xdrs, objp, FHSIZE))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fhandle3(xdrs, objp)
	XDR *xdrs;
	fhandle3 *objp;
{

	rpc_inline_t *buf;

	if (!xdr_bytes(xdrs, (char **)&objp->fhandle3_val, (u_int *) &objp->fhandle3_len, FHSIZE3))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_fhstatus(xdrs, objp)
	XDR *xdrs;
	fhstatus *objp;
{

	rpc_inline_t *buf;

	if (!xdr_u_int(xdrs, &objp->fhs_status))
		return (FALSE);
	switch (objp->fhs_status) {
	case 0:
		if (!xdr_fhandle(xdrs, objp->fhstatus_u.fhs_fhandle))
			return (FALSE);
		break;
	}
	return (TRUE);
}

#define	fhs_fh	fhstatus_u.fhs_fhandle

bool_t
xdr_mountstat3(xdrs, objp)
	XDR *xdrs;
	mountstat3 *objp;
{

	rpc_inline_t *buf;

	if (!xdr_enum(xdrs, (enum_t *)objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_mountres3_ok(xdrs, objp)
	XDR *xdrs;
	mountres3_ok *objp;
{

	rpc_inline_t *buf;

	if (!xdr_fhandle3(xdrs, &objp->fhandle))
		return (FALSE);
	if (!xdr_array(xdrs, (char **)&objp->auth_flavors.auth_flavors_val, (u_int *) &objp->auth_flavors.auth_flavors_len, ~0,
		sizeof (int), (xdrproc_t)xdr_int))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_mountres3(xdrs, objp)
	XDR *xdrs;
	mountres3 *objp;
{

	rpc_inline_t *buf;

	if (!xdr_mountstat3(xdrs, &objp->fhs_status))
		return (FALSE);
	switch (objp->fhs_status) {
	case MNT_OK:
		if (!xdr_mountres3_ok(xdrs, &objp->mountres3_u.mountinfo))
			return (FALSE);
		break;
	}
	return (TRUE);
}

bool_t
xdr_dirpath(xdrs, objp)
	XDR *xdrs;
	dirpath *objp;
{

	rpc_inline_t *buf;

	if (!xdr_string(xdrs, objp, MNTPATHLEN))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_name(xdrs, objp)
	XDR *xdrs;
	name *objp;
{

	rpc_inline_t *buf;

	if (!xdr_string(xdrs, objp, MNTNAMLEN))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_groups(xdrs, objp)
	XDR *xdrs;
	groups *objp;
{

	rpc_inline_t *buf;

	if (!xdr_pointer(xdrs, (char **)objp, sizeof (struct groupnode), (xdrproc_t)xdr_groupnode))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_groupnode(xdrs, objp)
	XDR *xdrs;
	groupnode *objp;
{

	rpc_inline_t *buf;

	groupnode *tmp_groupnode;
	bool_t more_data = TRUE;
	bool_t first_objp = TRUE;


	if (xdrs->x_op == XDR_DECODE) {

		while (more_data) {

			void bzero();

			if (!xdr_name(xdrs, &objp->gr_name))
				return (FALSE);
			if (!xdr_bool(xdrs, &more_data))
				return (FALSE);

			if (!more_data) {
				objp->gr_next = NULL;
				break;
			}

			if (objp->gr_next == NULL) {
				objp->gr_next = (groupnode *)
					mem_alloc(sizeof (groupnode));
				if (objp->gr_next == NULL)
					return (FALSE);
				bzero(objp->gr_next, sizeof (groupnode));
			}
			objp = objp->gr_next;
		}

	} else if (xdrs->x_op == XDR_ENCODE) {

		while (more_data) {
			if (!xdr_name(xdrs, &objp->gr_name))
				return (FALSE);
			objp = objp->gr_next;
			if (objp == NULL)
				more_data = FALSE;
			if (!xdr_bool(xdrs, &more_data))
				return (FALSE);
		}

	} else {

		while (more_data) {
			if (!xdr_name(xdrs, &objp->gr_name))
				return (FALSE);
			tmp_groupnode = objp;
			objp = objp->gr_next;
			if (objp == NULL)
				more_data = FALSE;
			if (!first_objp)
				mem_free(tmp_groupnode, sizeof (groupnode));
			else
				first_objp = FALSE;
		}

	}
	return (TRUE);
}

bool_t
xdr_exports(xdrs, objp)
	XDR *xdrs;
	exports *objp;
{

	rpc_inline_t *buf;

	if (!xdr_pointer(xdrs, (char **)objp, sizeof (struct exportnode), (xdrproc_t)xdr_exportnode))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_exportnode(xdrs, objp)
	XDR *xdrs;
	exportnode *objp;
{

	rpc_inline_t *buf;

	exportnode *tmp_exportnode;
	bool_t more_data = TRUE;
	bool_t first_objp = TRUE;


	if (xdrs->x_op == XDR_DECODE) {

		while (more_data) {

			void bzero();

			if (!xdr_dirpath(xdrs, &objp->ex_dir))
				return (FALSE);
			if (!xdr_groups(xdrs, &objp->ex_groups))
				return (FALSE);
			if (!xdr_bool(xdrs, &more_data))
				return (FALSE);

			if (!more_data) {
				objp->ex_next = NULL;
				break;
			}

			if (objp->ex_next == NULL) {
				objp->ex_next = (exportnode *)
					mem_alloc(sizeof (exportnode));
				if (objp->ex_next == NULL)
					return (FALSE);
				bzero(objp->ex_next, sizeof (exportnode));
			}
			objp = objp->ex_next;
		}

	} else if (xdrs->x_op == XDR_ENCODE) {

		while (more_data) {
			if (!xdr_dirpath(xdrs, &objp->ex_dir))
				return (FALSE);
			if (!xdr_groups(xdrs, &objp->ex_groups))
				return (FALSE);
			objp = objp->ex_next;
			if (objp == NULL)
				more_data = FALSE;
			if (!xdr_bool(xdrs, &more_data))
				return (FALSE);
		}

	} else {

		while (more_data) {
			if (!xdr_dirpath(xdrs, &objp->ex_dir))
				return (FALSE);
			if (!xdr_groups(xdrs, &objp->ex_groups))
				return (FALSE);
			tmp_exportnode = objp;
			objp = objp->ex_next;
			if (objp == NULL)
				more_data = FALSE;
			if (!first_objp)
				mem_free(tmp_exportnode, sizeof (exportnode));
			else
				first_objp = FALSE;
		}

	}
	return (TRUE);
}

bool_t
xdr_ppathcnf(xdrs, objp)
	XDR *xdrs;
	ppathcnf *objp;
{

	rpc_inline_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE(xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_int(xdrs, &objp->pc_link_max))
				return (FALSE);
			if (!xdr_short(xdrs, &objp->pc_max_canon))
				return (FALSE);
			if (!xdr_short(xdrs, &objp->pc_max_input))
				return (FALSE);
			if (!xdr_short(xdrs, &objp->pc_name_max))
				return (FALSE);
			if (!xdr_short(xdrs, &objp->pc_path_max))
				return (FALSE);
			if (!xdr_short(xdrs, &objp->pc_pipe_buf))
				return (FALSE);
		} else {
#if defined(_LP64) || defined(_KERNEL)
			IXDR_PUT_INT32(buf, objp->pc_link_max);
			IXDR_PUT_SHORT(buf, objp->pc_max_canon);
			IXDR_PUT_SHORT(buf, objp->pc_max_input);
			IXDR_PUT_SHORT(buf, objp->pc_name_max);
			IXDR_PUT_SHORT(buf, objp->pc_path_max);
			IXDR_PUT_SHORT(buf, objp->pc_pipe_buf);
#else
			IXDR_PUT_LONG(buf, objp->pc_link_max);
			IXDR_PUT_SHORT(buf, objp->pc_max_canon);
			IXDR_PUT_SHORT(buf, objp->pc_max_input);
			IXDR_PUT_SHORT(buf, objp->pc_name_max);
			IXDR_PUT_SHORT(buf, objp->pc_path_max);
			IXDR_PUT_SHORT(buf, objp->pc_pipe_buf);
#endif
		}
		if (!xdr_u_char(xdrs, &objp->pc_vdisable))
			return (FALSE);
		if (!xdr_char(xdrs, &objp->pc_xxx))
			return (FALSE);
		buf = XDR_INLINE(xdrs, (2) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_vector(xdrs, (char *)objp->pc_mask, 2,
				sizeof (short), (xdrproc_t)xdr_short))
				return (FALSE);
		} else {
#if defined(_LP64) || defined(_KERNEL)
			{
				short *genp;

				for (i = 0, genp = objp->pc_mask;
					i < 2; i++) {
					IXDR_PUT_SHORT(buf, *genp++);
				}
			}
#else
			{
				short *genp;

				for (i = 0, genp = objp->pc_mask;
					i < 2; i++) {
					IXDR_PUT_SHORT(buf, *genp++);
				}
			}
#endif
		}
		return (TRUE);
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE(xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_int(xdrs, &objp->pc_link_max))
				return (FALSE);
			if (!xdr_short(xdrs, &objp->pc_max_canon))
				return (FALSE);
			if (!xdr_short(xdrs, &objp->pc_max_input))
				return (FALSE);
			if (!xdr_short(xdrs, &objp->pc_name_max))
				return (FALSE);
			if (!xdr_short(xdrs, &objp->pc_path_max))
				return (FALSE);
			if (!xdr_short(xdrs, &objp->pc_pipe_buf))
				return (FALSE);
		} else {
#if defined(_LP64) || defined(_KERNEL)
			objp->pc_link_max = IXDR_GET_INT32(buf);
			objp->pc_max_canon = IXDR_GET_SHORT(buf);
			objp->pc_max_input = IXDR_GET_SHORT(buf);
			objp->pc_name_max = IXDR_GET_SHORT(buf);
			objp->pc_path_max = IXDR_GET_SHORT(buf);
			objp->pc_pipe_buf = IXDR_GET_SHORT(buf);
#else
			objp->pc_link_max = IXDR_GET_LONG(buf);
			objp->pc_max_canon = IXDR_GET_SHORT(buf);
			objp->pc_max_input = IXDR_GET_SHORT(buf);
			objp->pc_name_max = IXDR_GET_SHORT(buf);
			objp->pc_path_max = IXDR_GET_SHORT(buf);
			objp->pc_pipe_buf = IXDR_GET_SHORT(buf);
#endif
		}
		if (!xdr_u_char(xdrs, &objp->pc_vdisable))
			return (FALSE);
		if (!xdr_char(xdrs, &objp->pc_xxx))
			return (FALSE);
		buf = XDR_INLINE(xdrs, (2) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_vector(xdrs, (char *)objp->pc_mask, 2,
				sizeof (short), (xdrproc_t)xdr_short))
				return (FALSE);
		} else {
#if defined(_LP64) || defined(_KERNEL)
			{
				short *genp;

				for (i = 0, genp = objp->pc_mask;
					i < 2; i++) {
					*genp++ = IXDR_GET_SHORT(buf);
				}
			}
#else
			{
				short *genp;

				for (i = 0, genp = objp->pc_mask;
					i < 2; i++) {
					*genp++ = IXDR_GET_SHORT(buf);
				}
			}
#endif
		}
		return (TRUE);
	}

	if (!xdr_int(xdrs, &objp->pc_link_max))
		return (FALSE);
	if (!xdr_short(xdrs, &objp->pc_max_canon))
		return (FALSE);
	if (!xdr_short(xdrs, &objp->pc_max_input))
		return (FALSE);
	if (!xdr_short(xdrs, &objp->pc_name_max))
		return (FALSE);
	if (!xdr_short(xdrs, &objp->pc_path_max))
		return (FALSE);
	if (!xdr_short(xdrs, &objp->pc_pipe_buf))
		return (FALSE);
	if (!xdr_u_char(xdrs, &objp->pc_vdisable))
		return (FALSE);
	if (!xdr_char(xdrs, &objp->pc_xxx))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->pc_mask, 2,
		sizeof (short), (xdrproc_t)xdr_short))
		return (FALSE);
	return (TRUE);
}
